package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import java.io.*;
import org.apache.log4j.*;
import rs.etf.pp1.symboltable.*;
import rs.etf.pp1.symboltable.concepts.*;
import rs.ac.bg.etf.pp1.ast.*;

parser code {:
		
	Logger log = Logger.getLogger(getClass());
	
	boolean syntaxErrorFound = false;
	
	public void report_fatal_error(String message, Object info) throws java.lang.Exception
	{
		done_parsing();
		report_error(message, info);
		Tab.dump();
	}
	
	public void syntax_error(Symbol cur_token)
	{
		report_error("Sintaksna greska", cur_token);
		syntaxErrorFound = true;
	}
	
	public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception
	{
		report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
	}
	
	public void report_error(String message, Object info)
	{
		StringBuilder msg = new StringBuilder(message);
		if(info instanceof Symbol)
		{
			msg.append(" na liniji ").append(((Symbol)info).left);
		}
		log.error(msg.toString());
	}
	
	public void report_info(String message, Object info)
	{
		StringBuilder msg = new StringBuilder(message);
		if(info instanceof Symbol)
		{
			msg.append(" na liniji ").append(((Symbol)info).left);
		}
		log.info(msg.toString());
	}
	
	public void report_debug(String message, Object info)
	{
		StringBuilder msg = new StringBuilder(message);
		if(info instanceof Symbol)
		{
			msg.append(" na liniji ").append(((Symbol)info).left);
		}
		log.debug(msg.toString());
	}
:}

scan with {:
	Symbol s = this.getScanner().next_token();
	if(s != null && s.value != null)
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}



/**
 *  TERMINALS: 
 *  
 *  CONTROL FLOW
 *  LITERALS
 *  PUNCTUATION
 *  OPERATORS
 *  	ARITHMETIC
 *  	COMPARISON
 *  	LOGIC
 *  	ASSIGNMENT
 *  	SIDE-EFFECT
 *  	ALLOCATION
 *  PARENTHESES
 *  CLASS REALATED
 *  OTHER
 *  
 */

/** CONTROL FLOW TERMINALS */
terminal IF, ELSE, BREAK, DO, WHILE, CONTINUE, RETURN;


/** LITERALS */
terminal Integer NUMBER;
terminal String CHAR;
terminal String BOOL;


/** PUNCTUATION */
terminal COMMA, SEMICOLON, DOT;


/** OPERATORS */

/** ARITHMETIC OPERATORS */
terminal PLUS, MINUS, MULTUPLY, DIV, MOD;



/** COMPARISON OPERATORS */
terminal EQUAL, NOT_EQUAL, GREATER, LESS, GREATER_OR_EQUEL, LESS_OR_EQUEL;

/** LOGIC OPERATORS */
terminal AND, OR;

/** ASSIGNMENT */
terminal ASSIGN;

/** SIDE-EFFECT */
terminal INC, DEC;

/** ALLOCATION */
terminal NEW;

/** END OF OPERATORS */


/** PARENTHESES */
terminal	OPEN_PARENTHESES, 	CLOSE_PARENTHESES,
			OPEN_BRACES, 		CLOSE_BRACES,
			OPEN_CHEVRONS, 		CLOSE_CHEVRONS;


/** CLASS RELATED */
terminal CLASS, EXTENDS;


/** OTHER */
terminal PROG, PRINT, READ, VOID, CONST;
terminal String IDENT;

/**
 * END OF TERMINALS
 */




/** NON TERMINALS */

non terminal rs.etf.pp1.symboltable.concepts.Obj Program;
non terminal rs.etf.pp1.symboltable.concepts.Obj VarDecl;
non terminal rs.etf.pp1.symboltable.concepts.Obj MethodDecl;
non terminal rs.etf.pp1.symboltable.concepts.Obj Statement;
non terminal rs.etf.pp1.symboltable.concepts.Obj DesignatorStatement;
non terminal rs.etf.pp1.symboltable.concepts.Obj Factor;
non terminal rs.etf.pp1.symboltable.concepts.Obj Designator;

non terminal Mulop;
non terminal Addop;
non terminal Relop;


non terminal rs.etf.pp1.symboltable.concepts.Struct Type;
non terminal rs.etf.pp1.symboltable.concepts.Struct VoidType;
non terminal rs.etf.pp1.symboltable.concepts.Struct ReturnType;
non terminal rs.etf.pp1.symboltable.concepts.Struct Expr;
non terminal rs.etf.pp1.symboltable.concepts.Struct Term;



/** END OF NON TERMINALS */


/** HELPER NON TERMINALS */

non terminal rs.etf.pp1.symboltable.concepts.Obj ProgramName;
non terminal ProgramBegin;
non terminal ProgramEnd;
non terminal rs.etf.pp1.symboltable.concepts.Obj MethodNameAndRetType;
non terminal MethodEnd;

non terminal rs.etf.pp1.symboltable.concepts.Obj Constant;


non terminal rs.etf.pp1.symboltable.concepts.Obj MultipleStatements;
non terminal rs.etf.pp1.symboltable.concepts.Obj MultipleVarDecl;
non terminal rs.etf.pp1.symboltable.concepts.Obj MultipleMethodDecl;

non terminal rs.etf.pp1.symboltable.concepts.Obj TermList;
non terminal rs.etf.pp1.symboltable.concepts.Obj TermElement;

non terminal rs.etf.pp1.symboltable.concepts.Obj OptionalExprList;
non terminal rs.etf.pp1.symboltable.concepts.Obj ExprList;
non terminal rs.etf.pp1.symboltable.concepts.Obj ExprElement;

non terminal rs.etf.pp1.symboltable.concepts.Obj VarDeclList;
non terminal rs.etf.pp1.symboltable.concepts.Obj VarDeclElement;

non terminal rs.etf.pp1.symboltable.concepts.Obj LValueDesignator;
non terminal rs.etf.pp1.symboltable.concepts.Obj RValueDesignator;

/** END HELPER NON TERMINALS */

precedence left PLUS, MINUS;
precedence left MULTUPLY, DIV, MOD;


/* TODO optional method decl*/
Program ::= (Program1) PROG ProgramName ProgramBegin MultipleMethodDecl ProgramEnd
			|
			(Program2) PROG ProgramName MultipleVarDecl ProgramBegin MultipleMethodDecl ProgramEnd
			;
			
ProgramName ::= (ProgName) IDENT:name;

ProgramBegin ::= (ProgramBegin1) OPEN_BRACES;
ProgramEnd ::= (ProgramEnd1) CLOSE_BRACES;

MultipleVarDecl ::= MultipleVarDecl VarDecl
					|
					VarDecl
					;
			
VarDecl ::= (VarDecl1) Type VarDeclList SEMICOLON;

VarDeclList ::= VarDeclList COMMA VarDeclElement
				|
				VarDeclElement
				;
			
VarDeclElement ::= 	(VarDeclElementArray) IDENT OPEN_CHEVRONS CLOSE_CHEVRONS 
					|
					(VarDeclElementSingle)IDENT
					;

MultipleMethodDecl ::= 	MultipleMethodDecl MethodDecl
						|
						MethodDecl
						;
						

/* TODO optional multiple statements */					
MethodDecl ::= 	MethodNameAndRetType OPEN_PARENTHESES CLOSE_PARENTHESES OPEN_BRACES MultipleStatements MethodEnd
				|
				MethodNameAndRetType OPEN_PARENTHESES CLOSE_PARENTHESES MultipleVarDecl OPEN_BRACES MultipleStatements MethodEnd
				;
				
MethodNameAndRetType ::= (MethodNameAndRetType1) ReturnType:type IDENT:name;

MethodEnd ::= (MethodEnd1) CLOSE_BRACES;

ReturnType ::= 	(VoidReturnType) VoidType
				|
				(TypeReturnType) Type
				;

VoidType ::= VOID;				

Type ::= (Type1) IDENT;

MultipleStatements ::= 	MultipleStatements Statement
						|
						Statement
						;

Statement ::= 	DesignatorStatement SEMICOLON
				|
				RETURN SEMICOLON 
				|
				RETURN Expr SEMICOLON
				|
				(PrintStatementComplex) PRINT OPEN_PARENTHESES Expr:expr COMMA Constant:constant CLOSE_PARENTHESES SEMICOLON
				|
				(PrintStatement) PRINT OPEN_PARENTHESES Expr:expr CLOSE_PARENTHESES SEMICOLON
				|
				(ReadStatement) READ OPEN_PARENTHESES LValueDesignator CLOSE_PARENTHESES SEMICOLON
				|
				OPEN_BRACES CLOSE_BRACES
				|
				OPEN_BRACES Statement CLOSE_BRACES
				;



DesignatorStatement ::= 	(DesignatorStatementAssignment) LValueDesignator ASSIGN Expr
							|
							/* TODO */
							(DesignatorStatementFunctionCall) Designator OPEN_PARENTHESES CLOSE_PARENTHESES
							|
							(DesignatorStatementInc)LValueDesignator INC
							|
							(DesignatorStatementDec) LValueDesignator DEC
							;

Expr ::=	(ExprWithMinus) MINUS Term:term OptionalExprList
			|
			(ExprWithNoMinus)Term:term OptionalExprList
			;
			
OptionalExprList ::= 	ExprList:list
						|
						/* empty */
						;
			
ExprList ::= 	ExprList ExprElement
				|
				ExprElement
				;

ExprElement ::= (ExprElement1) Addop Term;

Term ::= 	(MultiFactorTerm) Factor:factor TermList
			| 
			(SingleFactorTerm) Factor:factor
			;
			
TermList ::=	(TermListMultiple) TermList TermElement
				|
				(TermListSingle) TermElement
				;
				
TermElement ::= (TermElement1) Mulop Factor;

			/* TODO */
Factor ::= 	(VariableFactor)RValueDesignator:desigantor
			|
			/* TODO */
			(FuncttionCallFactor) Designator:designator OPEN_PARENTHESES CLOSE_PARENTHESES
			|
			(ConstantFactor) Constant:constant
			|
			(FactorParenExpr) OPEN_PARENTHESES Expr CLOSE_PARENTHESES
			|
			(FactorNewArray) NEW Type OPEN_CHEVRONS Expr CLOSE_CHEVRONS 
			;
			
Constant ::= (NumberConstant) NUMBER:number
			|
			(CharConstant) CHAR:ch
			|
			(BoolConstant) BOOL:bl
			;

LValueDesignator ::= (LValueDesignator1) Designator;
RValueDesignator ::= (RValueDesignator1) Designator;
			
Designator ::= (DesignatorSimple)IDENT
				|
				/* TODO ident designator*/
				(DesignatorArray) IDENT OPEN_CHEVRONS Expr CLOSE_CHEVRONS
				;
				
Relop ::= 	EQUAL
			|
			NOT_EQUAL
			|
			GREATER
			|
			LESS
			|
			GREATER_OR_EQUEL
			|
			LESS_OR_EQUEL
			;
			
Addop ::= 	(AddopPlus)PLUS
			|
			(AddopMinus)MINUS
			;
			
Mulop ::= 	(MulopMultiply)MULTUPLY
			|
			(MulopDiv)DIV
			|
			(MulopMod)MOD
			;

