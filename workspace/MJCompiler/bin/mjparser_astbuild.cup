package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import java.io.*;
import org.apache.log4j.*;
import rs.etf.pp1.symboltable.*;
import rs.etf.pp1.symboltable.concepts.*;
import rs.ac.bg.etf.pp1.ast.*;

parser code {:
		
	Logger log = Logger.getLogger(getClass());
	
	boolean syntaxErrorFound = false;
	
	public void report_fatal_error(String message, Object info) throws java.lang.Exception
	{
		done_parsing();
		report_error(message, info);
		Tab.dump();
	}
	
	public void syntax_error(Symbol cur_token)
	{
		report_error("Sintaksna greska", cur_token);
		syntaxErrorFound = true;
	}
	
	public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception
	{
		report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
	}
	
	public void report_error(String message, Object info)
	{
		StringBuilder msg = new StringBuilder(message);
		if(info instanceof Symbol)
		{
			msg.append(" na liniji ").append(((Symbol)info).left);
		}
		log.error(msg.toString());
	}
	
	public void report_info(String message, Object info)
	{
		StringBuilder msg = new StringBuilder(message);
		if(info instanceof Symbol)
		{
			msg.append(" na liniji ").append(((Symbol)info).left);
		}
		log.info(msg.toString());
	}
	
	public void report_debug(String message, Object info)
	{
		StringBuilder msg = new StringBuilder(message);
		if(info instanceof Symbol)
		{
			msg.append(" na liniji ").append(((Symbol)info).left);
		}
		log.debug(msg.toString());
	}
:}

scan with {:
	Symbol s = this.getScanner().next_token();
	if(s != null && s.value != null)
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}



/**
 *  TERMINALS: 
 *  
 *  CONTROL FLOW
 *  LITERALS
 *  PUNCTUATION
 *  OPERATORS
 *  	ARITHMETIC
 *  	COMPARISON
 *  	LOGIC
 *  	ASSIGNMENT
 *  	SIDE-EFFECT
 *  	ALLOCATION
 *  PARENTHESES
 *  CLASS REALATED
 *  OTHER
 *  
 */

/** CONTROL FLOW TERMINALS */
terminal IF, ELSE, BREAK, DO, WHILE, CONTINUE, RETURN;


/** LITERALS */
terminal Integer NUMBER;
terminal String CHAR;
terminal String STRING;
terminal String BOOL;


/** PUNCTUATION */
terminal COMMA, SEMICOLON, DOT;


/** OPERATORS */

/** ARITHMETIC OPERATORS */
terminal PLUS, MINUS, MULTUPLY, DIV, MOD;

/** COMPARISON OPERATORS */
terminal EQUAL, NOT_EQUAL, GREATER, LESS, GREATER_OR_EQUEL, LESS_OR_EQUEL;

/** LOGIC OPERATORS */
terminal AND, OR;

/** ASSIGNMENT */
terminal ASSIGN;

/** SIDE-EFFECT */
terminal INC, DEC;

/** ALLOCATION */
terminal NEW;

/** END OF OPERATORS */


/** PARENTHESES */
terminal	OPEN_PARENTHESES, 	CLOSE_PARENTHESES,
			OPEN_BRACES, 		CLOSE_BRACES,
			OPEN_CHEVRONS, 		CLOSE_CHEVRONS;


/** CLASS RELATED */
terminal CLASS, EXTENDS;


/** OTHER */
terminal PROG, PRINT, READ, VOID, CONST;
terminal String IDENT;

/**
 * END OF TERMINALS
 */





/** NON TERMINALS */

non terminal Decl Decl;
non terminal ConstDecl ConstDecl;
nonterminal VarDecl VarDecl;
nonterminal ClassDecl ClassDecl;
nonterminal MethodDecl MethodDecl;

non terminal FormalPars FormalPars;
non terminal Statement Statement;
non terminal DesignatorStatement DesignatorStatement;
non terminal ActPars ActPars;
non terminal Condition Condition;
nonterminal CondTerm CondTerm;
nonterminal CondFact CondFact;
non terminal Relop Relop;
nonterminal Addop Addop;
nonterminal Mulop Mulop;


non terminal Matched Matched;
nonterminal Unmatched Unmatched;


non terminal DeclAssignmenList DeclAssignmenList;
non terminal VarDeclList VarDeclList;
non terminal ClassBodyDecl ClassBodyDecl;
non terminal MultipleVarDecl MultipleVarDecl;
nonterminal OptionalMultipleVarDecl OptionalMultipleVarDecl;
non terminal MultipleMethodDecl MultipleMethodDecl;
non terminal MultipleStatement MultipleStatement;
nonterminal MultipleStatementHelper MultipleStatementHelper;
non terminal FormalPar FormalPar;
non terminal MultipleAddopTerm MultipleAddopTerm;
non terminal MultipleMulopFactor MultipleMulopFactor;
non terminal DesignatorElem DesignatorElem;
nonterminal MultipleDesignatorElem MultipleDesignatorElem;


non terminal ReturnType ReturnType;
non terminal rs.etf.pp1.symboltable.concepts.Struct Literal;

/* END OF NON TERMINALS */



/** NON TERMINALS FOR SEMANTIC ANALYSIS */

non terminal rs.etf.pp1.symboltable.concepts.Obj ProgName;
non terminal rs.etf.pp1.symboltable.concepts.Obj Program;
non terminal rs.etf.pp1.symboltable.concepts.Obj OptionalMultipleMethodDecl;
non terminal rs.etf.pp1.symboltable.concepts.Obj NewClass;
non terminal rs.etf.pp1.symboltable.concepts.Obj DerivedClass;
non terminal rs.etf.pp1.symboltable.concepts.Obj ParentType;
non terminal rs.etf.pp1.symboltable.concepts.Obj ClassName;
non terminal rs.etf.pp1.symboltable.concepts.Obj Designator;


non terminal rs.etf.pp1.symboltable.concepts.Struct Type;
non terminal rs.etf.pp1.symboltable.concepts.Struct Expr;
non terminal rs.etf.pp1.symboltable.concepts.Struct Term;
non terminal rs.etf.pp1.symboltable.concepts.Struct Factor;
non terminal rs.etf.pp1.symboltable.concepts.Struct MulopFactor;
non terminal rs.etf.pp1.symboltable.concepts.Struct VarDeclElem;
non terminal rs.etf.pp1.symboltable.concepts.Struct DeclAssignElement;




/* END OF  NON TERMINALS FOR SEMANTIC ANALYSIS */



Program ::= (ProgramNoDecl) PROG ProgName:p OPEN_BRACES MultipleMethodDecl:M1 CLOSE_BRACES {: RESULT=new ProgramNoDecl(p, M1); RESULT.setLine(pleft); :}
			|
			(ProgramDecl) PROG ProgName:p Decl:D1 OPEN_BRACES MultipleMethodDecl:M2 CLOSE_BRACES {: RESULT=new ProgramDecl(p, D1, M2); RESULT.setLine(pleft); :}
			;
ProgName ::= (ProgramName)IDENT:pName {: RESULT=new ProgramName(pName); RESULT.setLine(pNameleft); :}
;

MultipleMethodDecl ::=  MethodDecl:M1 {: RESULT=new MultipleMethodDeclDerived1(M1); RESULT.setLine(M1left); :}
						|
						MultipleMethodDecl:M1 MethodDecl:M2 {: RESULT=new MultipleMethodDeclDerived2(M1, M2); RESULT.setLine(M1left); :}
						;
						
OptionalMultipleMethodDecl ::=  MultipleMethodDecl:M1 {: RESULT=new OptionalMultipleMethodDeclDerived1(M1); RESULT.setLine(M1left); :}
								| {: RESULT=new OptionalMultipleMethodDeclDerived2(); :}
								 /* empty */
								;


Decl ::= ConstDecl:C1 {: RESULT=new DeclDerived1(C1); RESULT.setLine(C1left); :}
		 |
		 VarDecl:V1 {: RESULT=new DeclDerived2(V1); RESULT.setLine(V1left); :}
		 |
		 ClassDecl:C1 {: RESULT=new DeclDerived3(C1); RESULT.setLine(C1left); :}
		 |
		 Decl:D1 ConstDecl:C2 {: RESULT=new DeclDerived4(D1, C2); RESULT.setLine(D1left); :}
		 | 
		 Decl:D1 VarDecl:V2 {: RESULT=new DeclDerived5(D1, V2); RESULT.setLine(D1left); :}
		 |
		 Decl:D1 ClassDecl:C2 {: RESULT=new DeclDerived6(D1, C2); RESULT.setLine(D1left); :}
		 ;


Literal ::= (NumberLiteral) NUMBER:N1 {: RESULT=new NumberLiteral(N1); RESULT.setLine(N1left); :}
			|
			(CharLiteral) CHAR:C1 {: RESULT=new CharLiteral(C1); RESULT.setLine(C1left); :}
			|
			(BoolLiteral) BOOL:B1 {: RESULT=new BoolLiteral(B1); RESULT.setLine(B1left); :}
			;

DeclAssignElement ::= (DeclAssignElem) IDENT:name ASSIGN Literal:value {: RESULT=new DeclAssignElem(name, value); RESULT.setLine(nameleft); :};

DeclAssignmenList ::= DeclAssignElement:D1 {: RESULT=new DeclAssignmenListDerived1(D1); RESULT.setLine(D1left); :}
					  |
					  DeclAssignmenList:D1 COMMA DeclAssignElement:D2 {: RESULT=new DeclAssignmenListDerived2(D1, D2); RESULT.setLine(D1left); :}
					  ;

ConstDecl ::= (CnstDecl) CONST Type:type DeclAssignmenList:D1 SEMICOLON {: RESULT=new CnstDecl(type, D1); RESULT.setLine(typeleft); :}
				|
				(ErrorConstDecl)CONST error SEMICOLON
				{:
					parser.log.info("Uspesan oporavak od greske dodele vrednosti.");
				:} {: RESULT=new ErrorConstDecl(); :}
			  ;

VarDeclElem ::= (SingleVarDeclElem) IDENT:name {: RESULT=new SingleVarDeclElem(name); RESULT.setLine(nameleft); :}
				|
				(ArrayVarDeclElem) IDENT:name OPEN_CHEVRONS CLOSE_CHEVRONS {: RESULT=new ArrayVarDeclElem(name); RESULT.setLine(nameleft); :}
				;

VarDeclList ::= VarDeclElem:V1 {: RESULT=new VarDeclListDerived1(V1); RESULT.setLine(V1left); :}
				|
				VarDeclElem:V1 COMMA VarDeclList:V2 {: RESULT=new VarDeclListDerived2(V1, V2); RESULT.setLine(V1left); :} 
				;


VarDecl ::= (VariableDecl) Type:varType VarDeclList:V1 SEMICOLON {: RESULT=new VariableDecl(varType, V1); RESULT.setLine(varTypeleft); :}
			|
			(VariableDeclError) error SEMICOLON 
			{:
				parser.log.info("Uspesan oporavak od greske deklaracije promenljive.");
			:} {: RESULT=new VariableDeclError(); :}
			;

MultipleVarDecl ::= VarDecl:V1 {: RESULT=new MultipleVarDeclDerived1(V1); RESULT.setLine(V1left); :}
				   |
				   MultipleVarDecl:M1 VarDecl:V2 {: RESULT=new MultipleVarDeclDerived2(M1, V2); RESULT.setLine(M1left); :}
				   ;
				   
OptionalMultipleVarDecl ::= MultipleVarDecl:M1 {: RESULT=new OptionalMultipleVarDeclDerived1(M1); RESULT.setLine(M1left); :}
							| {: RESULT=new OptionalMultipleVarDeclDerived2(); :}
							/* empty */
							;

ClassBodyDecl ::= OptionalMultipleVarDecl:O1 OPEN_BRACES OptionalMultipleMethodDecl:O2 CLOSE_BRACES {: RESULT=new ClassBodyDeclDerived1(O1, O2); RESULT.setLine(O1left); :}
				   /*
				   |
				   MultipleVarDecl
				  |
				  OPEN_BRACES OptionalMultipleMethodDecl CLOSE_BRACES
				  */
				  ;

ClassDecl ::= (CldDcl1) NewClass:N1 OPEN_BRACES ClassBodyDecl:C2 CLOSE_BRACES {: RESULT=new CldDcl1(N1, C2); RESULT.setLine(N1left); :}
			  |
			  (CldDcl2) DerivedClass:D1 OPEN_BRACES ClassBodyDecl:C2 CLOSE_BRACES {: RESULT=new CldDcl2(D1, C2); RESULT.setLine(D1left); :}
			  |
			 (CldDcl3) NewClass:N1 OPEN_BRACES CLOSE_BRACES {: RESULT=new CldDcl3(N1); RESULT.setLine(N1left); :}
			  |
			  (CldDcl4) DerivedClass:D1 OPEN_BRACES CLOSE_BRACES {: RESULT=new CldDcl4(D1); RESULT.setLine(D1left); :}
			  ;
			  

NewClass ::= (NClass) CLASS ClassName: name {: RESULT=new NClass(name); RESULT.setLine(nameleft); :};

DerivedClass ::= (DClass) CLASS ClassName:name EXTENDS Type:type {: RESULT=new DClass(name, type); RESULT.setLine(nameleft); :};
		
ClassName ::= (ClassN) IDENT:name {: RESULT=new ClassN(name); RESULT.setLine(nameleft); :};

ReturnType ::= Type:t {: RESULT=new ReturnTypeDerived1(t); RESULT.setLine(tleft); :}
			   |
			   VOID {: RESULT=new ReturnTypeDerived2(); :} 
			   ;

MethodDecl ::= 	ReturnType:R1 IDENT:I2   OPEN_PARENTHESES CLOSE_PARENTHESES OptionalMultipleVarDecl:O3 OPEN_BRACES MultipleStatement:M4 CLOSE_BRACES {: RESULT=new MethodDeclDerived1(R1, I2, O3, M4); RESULT.setLine(R1left); :} 
				|
				ReturnType:R1  IDENT:I2  OPEN_PARENTHESES FormalPars:F3 CLOSE_PARENTHESES OptionalMultipleVarDecl:O4 OPEN_BRACES MultipleStatement:M5 CLOSE_BRACES {: RESULT=new MethodDeclDerived2(R1, I2, F3, O4, M5); RESULT.setLine(R1left); :} 
				|
				ReturnType:R1  IDENT:I2  OPEN_PARENTHESES CLOSE_PARENTHESES OptionalMultipleVarDecl:O3 OPEN_BRACES CLOSE_BRACES {: RESULT=new MethodDeclDerived3(R1, I2, O3); RESULT.setLine(R1left); :} 
				|
				ReturnType:R1  IDENT:I2  OPEN_PARENTHESES FormalPars:F3 CLOSE_PARENTHESES OptionalMultipleVarDecl:O4 OPEN_BRACES CLOSE_BRACES {: RESULT=new MethodDeclDerived4(R1, I2, F3, O4); RESULT.setLine(R1left); :} 
				;

FormalPar ::= Type:T1 IDENT:I2 {: RESULT=new FormalParDerived1(T1, I2); RESULT.setLine(T1left); :} 
				|
			   Type:T1 IDENT:I2 OPEN_CHEVRONS CLOSE_CHEVRONS {: RESULT=new FormalParDerived2(T1, I2); RESULT.setLine(T1left); :}
			  ;

FormalPars ::= FormalPar:F1 {: RESULT=new FormalParsDerived1(F1); RESULT.setLine(F1left); :}
				|
				error
				{:
					parser.log.info("Uspesan oporavak od pogesne deklaracije parametra funkcije");
					
				:} {: RESULT=new FormalParsDerived2(); :}
			  	|
			   FormalPar:F1 COMMA FormalPars:F2 {: RESULT=new FormalParsDerived3(F1, F2); RESULT.setLine(F1left); :}
			   |
			   error COMMA FormalPars
				{:
					parser.log.info("Uspesan oporavak od pogesne deklaracije parametra funkcije");:F1
					
				:} {: RESULT=new FormalParsDerived4(F1); RESULT.setLine(F1left); :}
			   ;

Type ::= (Tp) IDENT:typeName {: RESULT=new Tp(typeName); RESULT.setLine(typeNameleft); :} 
/*
{:
	Obj typeNode = Tab.find(typeName);
	if(typeNode == Tab.noObj)
	{
		parser.report_error("Nije pronadjen tip "+typeName+"u tabeli simbola", null);
		RESULT = Tab.noType;
	}
	else
	{
		if(Obj.Type != typeNode.getKind())
		{
			parser.report_error("Ime "+typeName+"ne predstavlja tip", null);
			RESULT = Tab.noType;
		}
		else
		{
			parser.report_info("Pronadjen tip "+typeName, null);
			RESULT = typeNode.getType();
		}
		
	}
:}
*/
;


Statement ::= 	Matched:M1 {: RESULT=new StatementDerived1(M1); RESULT.setLine(M1left); :} 
				|
				Unmatched:U1 {: RESULT=new StatementDerived2(U1); RESULT.setLine(U1left); :}
				|
				/*diff*/
				OPEN_BRACES MultipleStatementHelper:M1 CLOSE_BRACES {: RESULT=new StatementDerived3(M1); RESULT.setLine(M1left); :}
				;

Matched ::=  (MatchedDesignatorStatement) DesignatorStatement:D1 SEMICOLON {: RESULT=new MatchedDesignatorStatement(D1); RESULT.setLine(D1left); :}
			|
			IF OPEN_PARENTHESES Condition:C1 CLOSE_PARENTHESES Matched:M2 ELSE Matched:M3 {: RESULT=new MatchedDerived1(C1, M2, M3); RESULT.setLine(C1left); :}
			|
			IF OPEN_PARENTHESES error CLOSE_PARENTHESES Matched:M1 ELSE Matched
			{:
				parser.log.info("Uspesan oporavak od greske u uslovu if-a");:M2
			:} {: RESULT=new MatchedDerived2(M1, M2); RESULT.setLine(M1left); :}
			|
			DO Statement:S1 WHILE OPEN_PARENTHESES Condition:C2 CLOSE_PARENTHESES SEMICOLON {: RESULT=new MatchedDerived3(S1, C2); RESULT.setLine(S1left); :}
			|
			BREAK SEMICOLON {: RESULT=new MatchedDerived4(); :}
			|
			CONTINUE SEMICOLON {: RESULT=new MatchedDerived5(); :}
			|
			RETURN SEMICOLON {: RESULT=new MatchedDerived6(); :}
			|
			RETURN Expr:E1 SEMICOLON {: RESULT=new MatchedDerived7(E1); RESULT.setLine(E1left); :}
			|
			READ OPEN_PARENTHESES Designator:D1 CLOSE_PARENTHESES SEMICOLON {: RESULT=new MatchedDerived8(D1); RESULT.setLine(D1left); :}
			|
			(MatchedSimplePrintStatement) PRINT OPEN_PARENTHESES Expr:expr CLOSE_PARENTHESES SEMICOLON {: RESULT=new MatchedSimplePrintStatement(expr); RESULT.setLine(exprleft); :}
			|
			(MatchedComplexPrintStatement) PRINT OPEN_PARENTHESES Expr:expr  COMMA NUMBER:num CLOSE_PARENTHESES SEMICOLON {: RESULT=new MatchedComplexPrintStatement(expr, num); RESULT.setLine(exprleft); :}
			|
			/* empty */
			OPEN_BRACES CLOSE_BRACES {: RESULT=new MatchedDerived9(); :} 
			;

Unmatched ::=	IF OPEN_PARENTHESES Condition:C1 CLOSE_PARENTHESES Statement:S2 {: RESULT=new UnmatchedDerived1(C1, S2); RESULT.setLine(C1left); :}
				|
				IF OPEN_PARENTHESES error CLOSE_PARENTHESES Statement
				{:
					parser.log.info("Uspesan oporavak od greske u uslovu if-a");:S1
				:} {: RESULT=new UnmatchedDerived2(S1); RESULT.setLine(S1left); :}
				|
				IF OPEN_PARENTHESES Condition:C1 CLOSE_PARENTHESES Matched:M2 ELSE Unmatched:U3 {: RESULT=new UnmatchedDerived3(C1, M2, U3); RESULT.setLine(C1left); :}
				|
				IF OPEN_PARENTHESES error CLOSE_PARENTHESES Matched:M1 ELSE Unmatched
				{:
					parser.log.info("Uspesan oporavak od greske u uslovu if-a");:U2
				:} {: RESULT=new UnmatchedDerived4(M1, U2); RESULT.setLine(M1left); :}
				;
					
/*
Statement ::= 	DesignatorStatement SEMICOLON
				|
				IF OPEN_PARENTHESES Condition CLOSE_PARENTHESES Statement
				|
				IF OPEN_PARENTHESES Condition CLOSE_PARENTHESES Statement ELSE Statement
				|
				DO Statement WHILE OPEN_PARENTHESES Condition CLOSE_PARENTHESES SEMICOLON
				|
				BREAK SEMICOLON
				|
				CONTINUE SEMICOLON
				|
				RETURN SEMICOLON
				|
				RETURN Expr SEMICOLON
				|
				READ OPEN_PARENTHESES Designator CLOSE_PARENTHESES SEMICOLON
				|
				PRINT OPEN_PARENTHESES Expr CLOSE_PARENTHESES SEMICOLON
				|
				PRINT OPEN_PARENTHESES Expr  COMMA NUMBER CLOSE_PARENTHESES SEMICOLON
				|
				/* empty 
				OPEN_BRACES CLOSE_BRACES 
				|
				OPEN_BRACES MultipleStatementHelper CLOSE_BRACES
				;

*/
				
MultipleStatement ::= MultipleStatement:M1 Statement:S2 {: RESULT=new MultipleStatementDerived1(M1, S2); RESULT.setLine(M1left); :}
					  |
					  Statement:S1 {: RESULT=new MultipleStatementDerived2(S1); RESULT.setLine(S1left); :}
					  ;

MultipleStatementHelper ::= MultipleStatementHelper:M1 Statement:S2 {: RESULT=new MultipleStatementHelperDerived1(M1, S2); RESULT.setLine(M1left); :}
					  		|
					  		Statement:S1 {: RESULT=new MultipleStatementHelperDerived2(S1); RESULT.setLine(S1left); :}
					  		;
					  
DesignatorStatement ::= (DesignatorAssignment) Designator:D1 ASSIGN Expr:E2 {: RESULT=new DesignatorAssignment(D1, E2); RESULT.setLine(D1left); :}
						|
						(EmptyFunctionCall) Designator:D1 OPEN_PARENTHESES CLOSE_PARENTHESES {: RESULT=new EmptyFunctionCall(D1); RESULT.setLine(D1left); :}
						|
						 Designator:D1 OPEN_PARENTHESES ActPars:A2 CLOSE_PARENTHESES {: RESULT=new DesignatorStatementDerived1(D1, A2); RESULT.setLine(D1left); :}
						|
						(DecisgnatorInc) Designator:D1 INC {: RESULT=new DecisgnatorInc(D1); RESULT.setLine(D1left); :}
						|
						(DesignatorDec) Designator:D1 DEC {: RESULT=new DesignatorDec(D1); RESULT.setLine(D1left); :}
						|
						error SEMICOLON
						{:
							parser.log.info("Uspesan oporavak od greske dodele vrednosti.");
						:} {: RESULT=new DesignatorStatementDerived2(); :}
						;

ActPars ::=  (SingleExpression) Expr:expr {: RESULT=new SingleExpression(expr); RESULT.setLine(exprleft); :}
			|
			(MultiExpression) ActPars:morePars COMMA Expr:expr {: RESULT=new MultiExpression(morePars, expr); RESULT.setLine(moreParsleft); :}
			;
			
Condition ::= (SingleCondition) CondTerm:C1 {: RESULT=new SingleCondition(C1); RESULT.setLine(C1left); :}
			  |
			  (MultiCondition) Condition:C1 OR CondTerm:C2 {: RESULT=new MultiCondition(C1, C2); RESULT.setLine(C1left); :}
			  ;
CondTerm ::= (SingleCondTerm) CondFact:C1 {: RESULT=new SingleCondTerm(C1); RESULT.setLine(C1left); :} 
			 |
			 (MultiCondTerm) CondTerm:C1 AND CondFact:C2 {: RESULT=new MultiCondTerm(C1, C2); RESULT.setLine(C1left); :}
			 ;
CondFact ::= (SingleCondFact)Expr:E1 {: RESULT=new SingleCondFact(E1); RESULT.setLine(E1left); :}
			 |
			 (MultiCondFact)Expr:E1 Relop:R2 Expr:E3 {: RESULT=new MultiCondFact(E1, R2, E3); RESULT.setLine(E1left); :}
			 ;
			 
Expr ::= (PositiveExpr) Term:t MultipleAddopTerm:M1 {: RESULT=new PositiveExpr(t, M1); RESULT.setLine(tleft); :} 
		 |
		 (NegativeExpr) MINUS Term:t MultipleAddopTerm:M1 {: RESULT=new NegativeExpr(t, M1); RESULT.setLine(tleft); :} 
		 ;
		 
MultipleAddopTerm ::= MultipleAddopTerm:M1 Addop:A2 Term:T3 {: RESULT=new MultipleAddopTermDerived1(M1, A2, T3); RESULT.setLine(M1left); :}
					  | {: RESULT=new MultipleAddopTermDerived2(); :}
					  /* empty */
					  ;
Term ::= (TF) Factor:F1 {: RESULT=new TF(F1); RESULT.setLine(F1left); :}
		|
		 (MFT) Factor:F1 MultipleMulopFactor:M2 {: RESULT=new MFT(F1, M2); RESULT.setLine(F1left); :}
		;

MultipleMulopFactor ::= (RMF) MultipleMulopFactor:m Mulop:M1 Factor:f {: RESULT=new RMF(m, M1, f); RESULT.setLine(mleft); :}
						|
						(SMF) Mulop:M1 Factor:f {: RESULT=new SMF(M1, f); RESULT.setLine(M1left); :}
						;

Factor ::= Designator:D1 {: RESULT=new FactorDerived1(D1); RESULT.setLine(D1left); :}
			|
			(FactorEmptyFunctionCall)Designator:fun OPEN_PARENTHESES CLOSE_PARENTHESES {: RESULT=new FactorEmptyFunctionCall(fun); RESULT.setLine(funleft); :}
			|
			(FactorFunctionCall) Designator:fun OPEN_PARENTHESES ActPars:A1 CLOSE_PARENTHESES {: RESULT=new FactorFunctionCall(fun, A1); RESULT.setLine(funleft); :}
			|
			NUMBER:N1 {: RESULT=new FactorDerived2(N1); RESULT.setLine(N1left); :}
			|
			CHAR:C1 {: RESULT=new FactorDerived3(C1); RESULT.setLine(C1left); :}
			|
			BOOL:B1 {: RESULT=new FactorDerived4(B1); RESULT.setLine(B1left); :}
			|
			(NewFactor) NEW Type:type {: RESULT=new NewFactor(type); RESULT.setLine(typeleft); :}
			|
			(NewArrayFactor) NEW Type:T1 OPEN_CHEVRONS Expr:E2 CLOSE_CHEVRONS {: RESULT=new NewArrayFactor(T1, E2); RESULT.setLine(T1left); :}
			|
			OPEN_PARENTHESES Expr:E1 CLOSE_PARENTHESES {: RESULT=new FactorDerived5(E1); RESULT.setLine(E1left); :}
			;

			
DesignatorElem ::= 	DOT IDENT:I1 {: RESULT=new DesignatorElemDerived1(I1); RESULT.setLine(I1left); :}
					|
					(IndexingDesignatorElem) OPEN_CHEVRONS Expr:expr CLOSE_CHEVRONS {: RESULT=new IndexingDesignatorElem(expr); RESULT.setLine(exprleft); :}
					;
					
MultipleDesignatorElem ::= MultipleDesignatorElem:M1 DesignatorElem:D2 {: RESULT=new MultipleDesignatorElemDerived1(M1, D2); RESULT.setLine(M1left); :}
							|
							DesignatorElem:D1 {: RESULT=new MultipleDesignatorElemDerived2(D1); RESULT.setLine(D1left); :}
							;
Designator ::= (SingleDesignator) IDENT:i {: RESULT=new SingleDesignator(i); RESULT.setLine(ileft); :} /*TODO name not declared*/
				|
				(ArrayElementDesignator) IDENT:array /*TODO name not declared*/ MultipleDesignatorElem:M1 {: RESULT=new ArrayElementDesignator(array, M1); RESULT.setLine(arrayleft); :}
				;
				
Relop ::= 	EQUAL {: RESULT=new RelopDerived1(); :}
			|
			NOT_EQUAL {: RESULT=new RelopDerived2(); :}
			|
			GREATER {: RESULT=new RelopDerived3(); :}
			|
			LESS {: RESULT=new RelopDerived4(); :}
			|
			GREATER_OR_EQUEL {: RESULT=new RelopDerived5(); :}
			|
			LESS_OR_EQUEL {: RESULT=new RelopDerived6(); :}
			;
			
Addop ::= 	PLUS {: RESULT=new AddopDerived1(); :}
			|
			MINUS {: RESULT=new AddopDerived2(); :}
			;
			
Mulop ::= 	MULTUPLY {: RESULT=new MulopDerived1(); :}
			|
			DIV {: RESULT=new MulopDerived2(); :}
			|
			MOD {: RESULT=new MulopDerived3(); :}
			;