package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import java.io.*;
import org.apache.log4j.*;
import rs.etf.pp1.symboltable.*;
import rs.etf.pp1.symboltable.concepts.*;
import rs.ac.bg.etf.pp1.ast.*;

parser code {:
		
	Logger log = Logger.getLogger(getClass());
	
	boolean syntaxErrorFound = false;
	
	public void report_fatal_error(String message, Object info) throws java.lang.Exception
	{
		done_parsing();
		report_error(message, info);
		Tab.dump();
	}
	
	public void syntax_error(Symbol cur_token)
	{
		report_error("Sintaksna greska", cur_token);
		syntaxErrorFound = true;
	}
	
	public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception
	{
		report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
	}
	
	public void report_error(String message, Object info)
	{
		StringBuilder msg = new StringBuilder(message);
		if(info instanceof Symbol)
		{
			msg.append(" na liniji ").append(((Symbol)info).left);
		}
		log.error(msg.toString());
	}
	
	public void report_info(String message, Object info)
	{
		StringBuilder msg = new StringBuilder(message);
		if(info instanceof Symbol)
		{
			msg.append(" na liniji ").append(((Symbol)info).left);
		}
		log.info(msg.toString());
	}
	
	public void report_debug(String message, Object info)
	{
		StringBuilder msg = new StringBuilder(message);
		if(info instanceof Symbol)
		{
			msg.append(" na liniji ").append(((Symbol)info).left);
		}
		log.debug(msg.toString());
	}
:}

scan with {:
	Symbol s = this.getScanner().next_token();
	if(s != null && s.value != null)
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}



/**
 *  TERMINALS: 
 *  
 *  CONTROL FLOW
 *  LITERALS
 *  PUNCTUATION
 *  OPERATORS
 *  	ARITHMETIC
 *  	COMPARISON
 *  	LOGIC
 *  	ASSIGNMENT
 *  	SIDE-EFFECT
 *  	ALLOCATION
 *  PARENTHESES
 *  CLASS REALATED
 *  OTHER
 *  
 */

/** CONTROL FLOW TERMINALS */
terminal IF, ELSE, BREAK, DO, WHILE, CONTINUE, RETURN;


/** LITERALS */
terminal Integer NUMBER;
terminal String CHAR;
terminal String BOOL;


/** PUNCTUATION */
terminal COMMA, SEMICOLON, DOT;


/** OPERATORS */

/** ARITHMETIC OPERATORS */
terminal PLUS, MINUS, MULTUPLY, DIV, MOD;

/** COMPARISON OPERATORS */
terminal EQUAL, NOT_EQUAL, GREATER, LESS, GREATER_OR_EQUEL, LESS_OR_EQUEL;

/** LOGIC OPERATORS */
terminal AND, OR;

/** ASSIGNMENT */
terminal ASSIGN;

/** SIDE-EFFECT */
terminal INC, DEC;

/** ALLOCATION */
terminal NEW;

/** END OF OPERATORS */


/** PARENTHESES */
terminal	OPEN_PARENTHESES, 	CLOSE_PARENTHESES,
			OPEN_BRACES, 		CLOSE_BRACES,
			OPEN_CHEVRONS, 		CLOSE_CHEVRONS;


/** CLASS RELATED */
terminal CLASS, EXTENDS;


/** OTHER */
terminal PROG, PRINT, READ, VOID, CONST;
terminal String IDENT;

/**
 * END OF TERMINALS
 */




/** NON TERMINALS */

non terminal rs.etf.pp1.symboltable.concepts.Obj Program;
non terminal rs.etf.pp1.symboltable.concepts.Obj VarDecl;
non terminal rs.etf.pp1.symboltable.concepts.Obj MethodDecl;
non terminal rs.etf.pp1.symboltable.concepts.Obj Statement;
non terminal rs.etf.pp1.symboltable.concepts.Obj DesignatorStatement;
non terminal rs.etf.pp1.symboltable.concepts.Obj Factor;
non terminal rs.etf.pp1.symboltable.concepts.Obj Term;
non terminal rs.etf.pp1.symboltable.concepts.Obj Expr;
non terminal rs.etf.pp1.symboltable.concepts.Obj Designator;

non terminal Mulop Mulop;
non terminal Addop Addop;
non terminal Relop Relop;

non terminal rs.etf.pp1.symboltable.concepts.Struct Type;
non terminal rs.etf.pp1.symboltable.concepts.Struct VoidType;
non terminal rs.etf.pp1.symboltable.concepts.Struct ReturnType;



/** END OF NON TERMINALS */


/** HELPER NON TERMINALS */

non terminal rs.etf.pp1.symboltable.concepts.Obj MultipleStatements;
non terminal rs.etf.pp1.symboltable.concepts.Obj MultipleVarDecl;
non terminal rs.etf.pp1.symboltable.concepts.Obj MultipleMethodDecl;

non terminal rs.etf.pp1.symboltable.concepts.Obj TermList;
non terminal rs.etf.pp1.symboltable.concepts.Obj TermElement;

non terminal rs.etf.pp1.symboltable.concepts.Obj OptionalExprList;
non terminal rs.etf.pp1.symboltable.concepts.Obj ExprList;
non terminal rs.etf.pp1.symboltable.concepts.Obj ExprElement;

non terminal rs.etf.pp1.symboltable.concepts.Obj VarDeclList;
non terminal rs.etf.pp1.symboltable.concepts.Obj VarDeclElement;

/** END HELPER NON TERMINALS */


/* TODO optional method decl*/
Program ::= PROG IDENT:I1 OPEN_BRACES MultipleMethodDecl:M2 CLOSE_BRACES {: RESULT=new ProgramDerived1(I1, M2); RESULT.setLine(I1left); :}
			|
			PROG IDENT:I1 MultipleVarDecl:M2 OPEN_BRACES MultipleMethodDecl:M3 CLOSE_BRACES {: RESULT=new ProgramDerived2(I1, M2, M3); RESULT.setLine(I1left); :}
			;

MultipleVarDecl ::= VarDecl:V1 {: RESULT=new MultipleVarDeclDerived1(V1); RESULT.setLine(V1left); :}
					|
					MultipleVarDecl:M1 VarDecl:V2 {: RESULT=new MultipleVarDeclDerived2(M1, V2); RESULT.setLine(M1left); :}
					;
			
VarDecl ::= Type:T1 VarDeclList:V2 SEMICOLON {: RESULT=new VarDeclDerived1(T1, V2); RESULT.setLine(T1left); :};

VarDeclList ::= VarDeclElement:V1 {: RESULT=new VarDeclListDerived1(V1); RESULT.setLine(V1left); :}
				|
				VarDeclList:V1 COMMA VarDeclElement:V2 {: RESULT=new VarDeclListDerived2(V1, V2); RESULT.setLine(V1left); :}
				;
			
VarDeclElement ::= 	IDENT:I1 {: RESULT=new VarDeclElementDerived1(I1); RESULT.setLine(I1left); :} 
					|
					IDENT:I1 OPEN_CHEVRONS CLOSE_CHEVRONS {: RESULT=new VarDeclElementDerived2(I1); RESULT.setLine(I1left); :}
					;

MultipleMethodDecl ::= 	MethodDecl:M1 {: RESULT=new MultipleMethodDeclDerived1(M1); RESULT.setLine(M1left); :}
						|
						MultipleMethodDecl:M1 MethodDecl:M2 {: RESULT=new MultipleMethodDeclDerived2(M1, M2); RESULT.setLine(M1left); :}
						;
						

/* TODO optional multiple statements */					
MethodDecl ::= 	ReturnType:R1 IDENT:I2 OPEN_PARENTHESES CLOSE_PARENTHESES OPEN_BRACES MultipleStatements:M3 CLOSE_BRACES {: RESULT=new MethodDeclDerived1(R1, I2, M3); RESULT.setLine(R1left); :}
				|
				ReturnType:R1 IDENT:I2 OPEN_PARENTHESES CLOSE_PARENTHESES MultipleVarDecl:M3 OPEN_BRACES MultipleStatements:M4 CLOSE_BRACES {: RESULT=new MethodDeclDerived2(R1, I2, M3, M4); RESULT.setLine(R1left); :}
				;
				
ReturnType ::= 	VoidType:V1 {: RESULT=new ReturnTypeDerived1(V1); RESULT.setLine(V1left); :}
				|
				Type:T1 {: RESULT=new ReturnTypeDerived2(T1); RESULT.setLine(T1left); :}
				;

VoidType ::= VOID {: RESULT=new VoidTypeDerived1(); :};				

Type ::= IDENT:I1 {: RESULT=new TypeDerived1(I1); RESULT.setLine(I1left); :};

MultipleStatements ::= 	Statement:S1 {: RESULT=new MultipleStatementsDerived1(S1); RESULT.setLine(S1left); :}
						|
						MultipleStatements:M1 Statement:S2 {: RESULT=new MultipleStatementsDerived2(M1, S2); RESULT.setLine(M1left); :}
						;

Statement ::= 	DesignatorStatement:D1 SEMICOLON {: RESULT=new StatementDerived1(D1); RESULT.setLine(D1left); :}
				|
				RETURN SEMICOLON {: RESULT=new StatementDerived2(); :} 
				|
				RETURN Expr:E1 SEMICOLON {: RESULT=new StatementDerived3(E1); RESULT.setLine(E1left); :}
				|
				PRINT OPEN_PARENTHESES Expr:E1 CLOSE_PARENTHESES SEMICOLON {: RESULT=new StatementDerived4(E1); RESULT.setLine(E1left); :}
				|
				OPEN_BRACES CLOSE_BRACES {: RESULT=new StatementDerived5(); :}
				|
				OPEN_BRACES Statement:S1 CLOSE_BRACES {: RESULT=new StatementDerived6(S1); RESULT.setLine(S1left); :}
				;



DesignatorStatement ::= 	Designator:D1 ASSIGN Expr:E2 {: RESULT=new DesignatorStatementDerived1(D1, E2); RESULT.setLine(D1left); :}
							|
							/* TODO */
							/* function call*/
							Designator:D1 OPEN_PARENTHESES CLOSE_PARENTHESES {: RESULT=new DesignatorStatementDerived2(D1); RESULT.setLine(D1left); :}
							|
							Designator:D1 INC {: RESULT=new DesignatorStatementDerived3(D1); RESULT.setLine(D1left); :}
							|
							Designator:D1 DEC {: RESULT=new DesignatorStatementDerived4(D1); RESULT.setLine(D1left); :}
							;

Expr ::=	Term:T1 OptionalExprList:O2 {: RESULT=new ExprDerived1(T1, O2); RESULT.setLine(T1left); :}
			|
			MINUS Term:T1  OptionalExprList:O2 {: RESULT=new ExprDerived2(T1, O2); RESULT.setLine(T1left); :}
			;
			
OptionalExprList ::= 	ExprList:E1 {: RESULT=new OptionalExprListDerived1(E1); RESULT.setLine(E1left); :}
						| {: RESULT=new OptionalExprListDerived2(); :}
						/* empty */
						;
			
ExprList ::= 	ExprElement:E1 {: RESULT=new ExprListDerived1(E1); RESULT.setLine(E1left); :}
				|
				ExprList:E1 ExprElement:E2 {: RESULT=new ExprListDerived2(E1, E2); RESULT.setLine(E1left); :}
				;

ExprElement ::= Addop:A1 Term:T2 {: RESULT=new ExprElementDerived1(A1, T2); RESULT.setLine(A1left); :};

Term ::= 	Factor:F1 {: RESULT=new TermDerived1(F1); RESULT.setLine(F1left); :}
			| 
			Factor:F1 TermList:T2 {: RESULT=new TermDerived2(F1, T2); RESULT.setLine(F1left); :}
			;
			
TermList ::=	TermElement:T1 {: RESULT=new TermListDerived1(T1); RESULT.setLine(T1left); :}
				|
				TermList:T1 TermElement:T2 {: RESULT=new TermListDerived2(T1, T2); RESULT.setLine(T1left); :}
				;
				
TermElement ::= Mulop:M1 Factor:F2 {: RESULT=new TermElementDerived1(M1, F2); RESULT.setLine(M1left); :};


Factor ::= 	Designator:D1 {: RESULT=new FactorDerived1(D1); RESULT.setLine(D1left); :}
			|
			Designator:D1 OPEN_PARENTHESES CLOSE_PARENTHESES {: RESULT=new FactorDerived2(D1); RESULT.setLine(D1left); :}
			|
			NUMBER:N1 {: RESULT=new FactorDerived3(N1); RESULT.setLine(N1left); :}
			|
			CHAR:C1 {: RESULT=new FactorDerived4(C1); RESULT.setLine(C1left); :}
			|
			BOOL:B1 {: RESULT=new FactorDerived5(B1); RESULT.setLine(B1left); :}
			;

Designator ::= IDENT:I1 {: RESULT=new DesignatorDerived1(I1); RESULT.setLine(I1left); :};

Relop ::= 	EQUAL {: RESULT=new RelopDerived1(); :}
			|
			NOT_EQUAL {: RESULT=new RelopDerived2(); :}
			|
			GREATER {: RESULT=new RelopDerived3(); :}
			|
			LESS {: RESULT=new RelopDerived4(); :}
			|
			GREATER_OR_EQUEL {: RESULT=new RelopDerived5(); :}
			|
			LESS_OR_EQUEL {: RESULT=new RelopDerived6(); :}
			;
			
Addop ::= 	PLUS {: RESULT=new AddopDerived1(); :}
			|
			MINUS {: RESULT=new AddopDerived2(); :}
			;
			
Mulop ::= 	MULTUPLY {: RESULT=new MulopDerived1(); :}
			|
			DIV {: RESULT=new MulopDerived2(); :}
			|
			MOD {: RESULT=new MulopDerived3(); :}
			;

