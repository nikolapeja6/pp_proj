package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import java.io.*;
import org.apache.log4j.*;
import rs.etf.pp1.symboltable.*;
import rs.etf.pp1.symboltable.concepts.*;
import rs.ac.bg.etf.pp1.ast.*;

parser code {:
		
	Logger log = Logger.getLogger(getClass());
	
	boolean syntaxErrorFound = false;
	
	public void report_fatal_error(String message, Object info) throws java.lang.Exception
	{
		done_parsing();
		report_error(message, info);
		Tab.dump();
	}
	
	public void syntax_error(Symbol cur_token)
	{
		report_error("Sintaksna greska", cur_token);
		syntaxErrorFound = true;
	}
	
	public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception
	{
		report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
	}
	
	public void report_error(String message, Object info)
	{
		StringBuilder msg = new StringBuilder(message);
		if(info instanceof Symbol)
		{
			msg.append(" na liniji ").append(((Symbol)info).left);
		}
		log.error(msg.toString());
	}
	
	public void report_info(String message, Object info)
	{
		StringBuilder msg = new StringBuilder(message);
		if(info instanceof Symbol)
		{
			msg.append(" na liniji ").append(((Symbol)info).left);
		}
		log.info(msg.toString());
	}
	
	public void report_debug(String message, Object info)
	{
		StringBuilder msg = new StringBuilder(message);
		if(info instanceof Symbol)
		{
			msg.append(" na liniji ").append(((Symbol)info).left);
		}
		log.debug(msg.toString());
	}
:}

scan with {:
	Symbol s = this.getScanner().next_token();
	if(s != null && s.value != null)
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}



/**
 *  TERMINALS: 
 *  
 *  CONTROL FLOW
 *  LITERALS
 *  PUNCTUATION
 *  OPERATORS
 *  	ARITHMETIC
 *  	COMPARISON
 *  	LOGIC
 *  	ASSIGNMENT
 *  	SIDE-EFFECT
 *  	ALLOCATION
 *  PARENTHESES
 *  CLASS REALATED
 *  OTHER
 *  
 */

/** CONTROL FLOW TERMINALS */
terminal IF, ELSE, BREAK, DO, WHILE, CONTINUE, RETURN;


/** LITERALS */
terminal Integer NUMBER;
terminal String CHAR;
terminal String BOOL;


/** PUNCTUATION */
terminal COMMA, SEMICOLON, DOT;


/** OPERATORS */

/** ARITHMETIC OPERATORS */
terminal PLUS, MINUS, MULTUPLY, DIV, MOD;



/** COMPARISON OPERATORS */
terminal EQUAL, NOT_EQUAL, GREATER, LESS, GREATER_OR_EQUEL, LESS_OR_EQUEL;

/** LOGIC OPERATORS */
terminal AND, OR;

/** ASSIGNMENT */
terminal ASSIGN;

/** SIDE-EFFECT */
terminal INC, DEC;

/** ALLOCATION */
terminal NEW;

/** END OF OPERATORS */


/** PARENTHESES */
terminal	OPEN_PARENTHESES, 	CLOSE_PARENTHESES,
			OPEN_BRACES, 		CLOSE_BRACES,
			OPEN_CHEVRONS, 		CLOSE_CHEVRONS;


/** CLASS RELATED */
terminal CLASS, EXTENDS;


/** OTHER */
terminal PROG, PRINT, READ, VOID, CONST;
terminal String IDENT;

/**
 * END OF TERMINALS
 */




/** NON TERMINALS */

non terminal rs.etf.pp1.symboltable.concepts.Obj Program;
non terminal rs.etf.pp1.symboltable.concepts.Obj VarDecl;
non terminal rs.etf.pp1.symboltable.concepts.Obj MethodDecl;
non terminal rs.etf.pp1.symboltable.concepts.Obj Statement;
non terminal rs.etf.pp1.symboltable.concepts.Obj DesignatorStatement;
non terminal rs.etf.pp1.symboltable.concepts.Obj Factor;
non terminal rs.etf.pp1.symboltable.concepts.Obj Designator;

non terminal Mulop Mulop;
non terminal Addop Addop;
non terminal Relop Relop;


non terminal rs.etf.pp1.symboltable.concepts.Struct Type;
non terminal rs.etf.pp1.symboltable.concepts.Struct VoidType;
non terminal rs.etf.pp1.symboltable.concepts.Struct ReturnType;
non terminal rs.etf.pp1.symboltable.concepts.Struct Expr;
non terminal rs.etf.pp1.symboltable.concepts.Struct Term;



/** END OF NON TERMINALS */


/** HELPER NON TERMINALS */

non terminal rs.etf.pp1.symboltable.concepts.Obj ProgramName;
non terminal ProgramEnd ProgramEnd;
non terminal rs.etf.pp1.symboltable.concepts.Obj MethodNameAndRetType;
non terminal MethodEnd MethodEnd;

non terminal rs.etf.pp1.symboltable.concepts.Obj Constant;


non terminal rs.etf.pp1.symboltable.concepts.Obj MultipleStatements;
non terminal rs.etf.pp1.symboltable.concepts.Obj MultipleVarDecl;
non terminal rs.etf.pp1.symboltable.concepts.Obj MultipleMethodDecl;

non terminal rs.etf.pp1.symboltable.concepts.Obj TermList;
non terminal rs.etf.pp1.symboltable.concepts.Obj TermElement;

non terminal rs.etf.pp1.symboltable.concepts.Obj OptionalExprList;
non terminal rs.etf.pp1.symboltable.concepts.Obj ExprList;
non terminal rs.etf.pp1.symboltable.concepts.Obj ExprElement;

non terminal rs.etf.pp1.symboltable.concepts.Obj VarDeclList;
non terminal rs.etf.pp1.symboltable.concepts.Obj VarDeclElement;

/** END HELPER NON TERMINALS */

precedence left PLUS, MINUS;
precedence left MULTUPLY, DIV, MOD;


/* TODO optional method decl*/
Program ::= (Program1) PROG ProgramName:P1 OPEN_BRACES MultipleMethodDecl:M2 ProgramEnd:P3 {: RESULT=new Program1(P1, M2, P3); RESULT.setLine(P1left); :}
			|
			(Program2) PROG ProgramName:P1 MultipleVarDecl:M2 OPEN_BRACES MultipleMethodDecl:M3 ProgramEnd:P4 {: RESULT=new Program2(P1, M2, M3, P4); RESULT.setLine(P1left); :}
			;
			
ProgramName ::= (ProgName) IDENT:name {: RESULT=new ProgName(name); RESULT.setLine(nameleft); :};

ProgramEnd ::= CLOSE_BRACES {: RESULT=new ProgramEndDerived1(); :};

MultipleVarDecl ::= MultipleVarDecl:M1 VarDecl:V2 {: RESULT=new MultipleVarDeclDerived1(M1, V2); RESULT.setLine(M1left); :}
					|
					VarDecl:V1 {: RESULT=new MultipleVarDeclDerived2(V1); RESULT.setLine(V1left); :}
					;
			
VarDecl ::= Type:T1 VarDeclList:V2 SEMICOLON {: RESULT=new VarDeclDerived1(T1, V2); RESULT.setLine(T1left); :};

VarDeclList ::= VarDeclList:V1 COMMA VarDeclElement:V2 {: RESULT=new VarDeclListDerived1(V1, V2); RESULT.setLine(V1left); :}
				|
				VarDeclElement:V1 {: RESULT=new VarDeclListDerived2(V1); RESULT.setLine(V1left); :}
				;
			
VarDeclElement ::= 	IDENT:I1 OPEN_CHEVRONS CLOSE_CHEVRONS {: RESULT=new VarDeclElementDerived1(I1); RESULT.setLine(I1left); :} 
					|
					IDENT:I1 {: RESULT=new VarDeclElementDerived2(I1); RESULT.setLine(I1left); :}
					;

MultipleMethodDecl ::= 	MultipleMethodDecl:M1 MethodDecl:M2 {: RESULT=new MultipleMethodDeclDerived1(M1, M2); RESULT.setLine(M1left); :}
						|
						MethodDecl:M1 {: RESULT=new MultipleMethodDeclDerived2(M1); RESULT.setLine(M1left); :}
						;
						

/* TODO optional multiple statements */					
MethodDecl ::= 	MethodNameAndRetType:M1 OPEN_PARENTHESES CLOSE_PARENTHESES OPEN_BRACES MultipleStatements:M2 MethodEnd:M3 {: RESULT=new MethodDeclDerived1(M1, M2, M3); RESULT.setLine(M1left); :}
				|
				MethodNameAndRetType:M1 OPEN_PARENTHESES CLOSE_PARENTHESES MultipleVarDecl:M2 OPEN_BRACES MultipleStatements:M3 MethodEnd:M4 {: RESULT=new MethodDeclDerived2(M1, M2, M3, M4); RESULT.setLine(M1left); :}
				;
				
MethodNameAndRetType ::= (MethodNameAndRetType1) ReturnType:type IDENT:name {: RESULT=new MethodNameAndRetType1(type, name); RESULT.setLine(typeleft); :};

MethodEnd ::= (MethodEnd1) CLOSE_BRACES {: RESULT=new MethodEnd1(); :};

ReturnType ::= 	(VoidReturnType) VoidType:V1 {: RESULT=new VoidReturnType(V1); RESULT.setLine(V1left); :}
				|
				(TypeReturnType) Type:T1 {: RESULT=new TypeReturnType(T1); RESULT.setLine(T1left); :}
				;

VoidType ::= VOID {: RESULT=new VoidTypeDerived1(); :};				

Type ::= (Type1) IDENT:I1 {: RESULT=new Type1(I1); RESULT.setLine(I1left); :};

MultipleStatements ::= 	MultipleStatements:M1 Statement:S2 {: RESULT=new MultipleStatementsDerived1(M1, S2); RESULT.setLine(M1left); :}
						|
						Statement:S1 {: RESULT=new MultipleStatementsDerived2(S1); RESULT.setLine(S1left); :}
						;

Statement ::= 	DesignatorStatement:D1 SEMICOLON {: RESULT=new StatementDerived1(D1); RESULT.setLine(D1left); :}
				|
				RETURN SEMICOLON {: RESULT=new StatementDerived2(); :} 
				|
				RETURN Expr:E1 SEMICOLON {: RESULT=new StatementDerived3(E1); RESULT.setLine(E1left); :}
				|
				(PrintStatement) PRINT OPEN_PARENTHESES Expr:expr CLOSE_PARENTHESES SEMICOLON {: RESULT=new PrintStatement(expr); RESULT.setLine(exprleft); :}
				|
				OPEN_BRACES CLOSE_BRACES {: RESULT=new StatementDerived4(); :}
				|
				OPEN_BRACES Statement:S1 CLOSE_BRACES {: RESULT=new StatementDerived5(S1); RESULT.setLine(S1left); :}
				;



DesignatorStatement ::= 	Designator:D1 ASSIGN Expr:E2 {: RESULT=new DesignatorStatementDerived1(D1, E2); RESULT.setLine(D1left); :}
							|
							/* TODO */
							/* function call*/
							Designator:D1 OPEN_PARENTHESES CLOSE_PARENTHESES {: RESULT=new DesignatorStatementDerived2(D1); RESULT.setLine(D1left); :}
							|
							Designator:D1 INC {: RESULT=new DesignatorStatementDerived3(D1); RESULT.setLine(D1left); :}
							|
							Designator:D1 DEC {: RESULT=new DesignatorStatementDerived4(D1); RESULT.setLine(D1left); :}
							;

Expr ::=	(ExprWithMinus) MINUS Term:term OptionalExprList:O1 {: RESULT=new ExprWithMinus(term, O1); RESULT.setLine(termleft); :}
			|
			(ExprWithNoMinus)Term:term OptionalExprList:O1 {: RESULT=new ExprWithNoMinus(term, O1); RESULT.setLine(termleft); :}
			;
			
OptionalExprList ::= 	ExprList:list {: RESULT=new OptionalExprListDerived1(list); RESULT.setLine(listleft); :}
						| {: RESULT=new OptionalExprListDerived2(); :}
						/* empty */
						;
			
ExprList ::= 	ExprList:E1 ExprElement:E2 {: RESULT=new ExprListDerived1(E1, E2); RESULT.setLine(E1left); :}
				|
				ExprElement:E1 {: RESULT=new ExprListDerived2(E1); RESULT.setLine(E1left); :}
				;

ExprElement ::= Addop:A1 Term:T2 {: RESULT=new ExprElementDerived1(A1, T2); RESULT.setLine(A1left); :};

Term ::= 	(MultiFactorTerm) Factor:factor TermList:T1 {: RESULT=new MultiFactorTerm(factor, T1); RESULT.setLine(factorleft); :}
			| 
			(SingleFactorTerm) Factor:factor {: RESULT=new SingleFactorTerm(factor); RESULT.setLine(factorleft); :}
			;
			
TermList ::=	(TermListMultiple) TermList:T1 TermElement:T2 {: RESULT=new TermListMultiple(T1, T2); RESULT.setLine(T1left); :}
				|
				(TermListSinge) TermElement:T1 {: RESULT=new TermListSinge(T1); RESULT.setLine(T1left); :}
				;
				
TermElement ::= (TermElement1) Mulop:M1 Factor:F2 {: RESULT=new TermElement1(M1, F2); RESULT.setLine(M1left); :};

			/* TODO */
Factor ::= 	(VariableFactor)Designator:desigantor {: RESULT=new VariableFactor(desigantor); RESULT.setLine(desigantorleft); :}
			|
			/* TODO */
			(FuncttionCallFactor) Designator:designator OPEN_PARENTHESES CLOSE_PARENTHESES {: RESULT=new FuncttionCallFactor(designator); RESULT.setLine(designatorleft); :}
			|
			(ConstantFactor) Constant:constant {: RESULT=new ConstantFactor(constant); RESULT.setLine(constantleft); :}
			;
			
Constant ::= (NumberConstant) NUMBER:number {: RESULT=new NumberConstant(number); RESULT.setLine(numberleft); :}
			|
			(CharConstant) CHAR:ch {: RESULT=new CharConstant(ch); RESULT.setLine(chleft); :}
			|
			(BoolConstant) BOOL:bl {: RESULT=new BoolConstant(bl); RESULT.setLine(blleft); :}
			;

Designator ::= IDENT:I1 {: RESULT=new DesignatorDerived1(I1); RESULT.setLine(I1left); :};

Relop ::= 	EQUAL {: RESULT=new RelopDerived1(); :}
			|
			NOT_EQUAL {: RESULT=new RelopDerived2(); :}
			|
			GREATER {: RESULT=new RelopDerived3(); :}
			|
			LESS {: RESULT=new RelopDerived4(); :}
			|
			GREATER_OR_EQUEL {: RESULT=new RelopDerived5(); :}
			|
			LESS_OR_EQUEL {: RESULT=new RelopDerived6(); :}
			;
			
Addop ::= 	PLUS {: RESULT=new AddopDerived1(); :}
			|
			MINUS {: RESULT=new AddopDerived2(); :}
			;
			
Mulop ::= 	MULTUPLY {: RESULT=new MulopDerived1(); :}
			|
			DIV {: RESULT=new MulopDerived2(); :}
			|
			MOD {: RESULT=new MulopDerived3(); :}
			;

